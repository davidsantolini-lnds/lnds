<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Mission : H√©l√®ne ‚ú® ‚Äî Ski Run (PS5 vibes)</title>
  <style>
    :root{
      --bg0:#050505;
      --pink:#ff6bd6;
      --rose:#ff9a9e;
      --pearl:#fecfef;
      --mint:#75f3c6;
      --glass:rgba(255,255,255,.08);
      --glass2:rgba(255,255,255,.12);
      --shadow:0 30px 90px rgba(0,0,0,.55);
      --soft:0 0 60px rgba(255,107,214,.20);
    }
    *{box-sizing:border-box;}
    html,body{height:100%; margin:0; background:var(--bg0); color:#fff; overflow:hidden;}
    body{font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial;}

    canvas#game{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      display:block;
      background:
        radial-gradient(circle at 50% 25%, #1a1025 0%, #000 70%),
        linear-gradient(180deg, #000, #06030c);
    }

    /* HUD */
    .hud{
      position:fixed; top:14px; left:14px; right:14px;
      display:flex; gap:12px; align-items:center;
      pointer-events:none; z-index:20;
    }
    .chip{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px; border-radius:999px;
      background:rgba(0,0,0,.38);
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(12px);
      box-shadow: 0 15px 50px rgba(0,0,0,.35);
      min-width: 190px;
    }
    .dot{ width:10px;height:10px;border-radius:50%; background:var(--mint); box-shadow:0 0 12px var(--mint); }
    .hud strong{font-size:.92rem;}
    .hud span{font-size:.82rem;color:rgba(255,255,255,.65)}
    .bar{
      flex:1; height:10px; border-radius:999px;
      background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.08);
      overflow:hidden;
    }
    .bar > i{
      display:block; height:100%; width:0%;
      background:linear-gradient(90deg, var(--rose), var(--pink), var(--mint));
      box-shadow: var(--soft);
      will-change: width;
    }
    .pill{
      padding:4px 10px; border-radius:999px;
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      font-size:.78rem; color:rgba(255,255,255,.72);
      white-space:nowrap;
    }

    /* Overlay start / finish */
    .overlay{
      position:fixed; inset:0;
      display:grid; place-items:center;
      z-index:30;
      background: radial-gradient(circle at 50% 35%, rgba(255,107,214,.14), rgba(0,0,0,.75) 55%, rgba(0,0,0,.92) 100%);
      padding:20px;
    }
    .panel{
      width:min(980px, 92vw);
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.14);
      border-radius:28px;
      padding:26px 24px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(14px);
      position:relative;
      overflow:hidden;
    }
    .panel:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(circle at 25% 20%, rgba(255,107,214,.25), transparent 45%),
        radial-gradient(circle at 75% 70%, rgba(117,243,198,.18), transparent 46%),
        radial-gradient(circle at 50% 110%, rgba(255,154,158,.16), transparent 55%);
      opacity:.95; pointer-events:none;
    }
    .panel > *{position:relative; z-index:1;}
    .kicker{
      display:inline-flex; align-items:center; gap:10px;
      padding:8px 12px; border-radius:999px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      font-size:.85rem; color:rgba(255,255,255,.78);
      letter-spacing:.3px;
    }
    .kicker b{color:#fff; font-weight:900;}
    h1{
      margin:14px 0 8px;
      font-size: clamp(2.2rem, 4.5vw, 3.4rem);
      line-height:1.05;
      text-shadow:0 0 26px rgba(255,107,214,.24);
    }
    p{margin:10px 0 0; color:rgba(255,255,255,.80); font-size:1.06rem; line-height:1.55; max-width: 70ch;}
    .row{display:flex; gap:12px; flex-wrap:wrap; margin-top:16px; align-items:center;}
    .btn{
      pointer-events:auto;
      cursor:pointer; border:none;
      padding:12px 16px; border-radius:16px;
      color:#fff; font-weight:900; letter-spacing:.2px;
      background:linear-gradient(90deg, var(--pink), var(--rose), var(--mint));
      box-shadow:0 25px 80px rgba(255,107,214,.20);
      border:1px solid rgba(255,255,255,.16);
      transition: transform .15s ease, filter .15s ease;
    }
    .btn:hover{transform: translateY(-1px); filter:brightness(1.06);}
    .btn.secondary{
      background: rgba(0,0,0,.20);
      border:1px solid rgba(255,255,255,.14);
      box-shadow:none;
      font-weight:800;
      color:rgba(255,255,255,.86);
    }
    .hint{
      margin-top:10px;
      color:rgba(255,255,255,.62);
      font-size:.92rem;
    }
    .grid{
      margin-top:14px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width: 900px){ .grid{grid-template-columns:1fr;} }
    .card{
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius:22px;
      padding:16px 14px;
    }
    .card h3{margin:0; font-size:1.02rem; letter-spacing:.2px;}
    .small{color:rgba(255,255,255,.66); font-size:.92rem; line-height:1.45; margin-top:8px;}

    /* Countdown (finish panel) */
    .countdown{ margin-top:14px; display:flex; gap:12px; flex-wrap:wrap; }
    .timebox{ background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:18px; padding:14px; min-width:110px; text-align:center; }
    .num{ font-size:2rem; font-weight:950; display:block; background:linear-gradient(90deg,var(--rose),var(--pearl)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
    .lab{ font-size:.75rem; text-transform:uppercase; color:rgba(255,255,255,.55); letter-spacing:1px; margin-top:4px; display:block; }

    /* confetti canvas */
    canvas#fx{
      position:fixed; inset:0; pointer-events:none; z-index:40;
    }

    @media (prefers-reduced-motion: reduce){
      .overlay{background: rgba(0,0,0,.9);}
    }
  </style>
</head>
<body>

<canvas id="game"></canvas>
<canvas id="fx"></canvas>

<div class="hud">
  <div class="chip">
    <i class="dot"></i>
    <div>
      <strong id="hudTitle">Ski Run ‚Äî Mission</strong><br/>
      <span id="hudSub">Passe les portes. Garde le flow.</span>
    </div>
  </div>
  <div class="bar"><i id="prog"></i></div>
  <div class="chip" style="min-width:260px; justify-content:space-between;">
    <div>
      <strong id="speed">0 km/h</strong><br/>
      <span id="score">Score 0 ¬∑ Combo x1</span>
    </div>
    <span class="pill" id="statePill">READY</span>
  </div>
</div>

<!-- START OVERLAY -->
<div class="overlay" id="startOverlay">
  <div class="panel">
    <span class="kicker"><b>STARTHOUSE</b> ¬∑ A-Team Winter Mission</span>
    <h1>Descente PS5 vibes. Pour H√©l√®ne. üéø‚ú®</h1>
    <p>
      Objectif : <b>passer les portes</b> sans rater le flow.
      Plus tu es propre, plus le combo grimpe. √Ä l‚Äôarriv√©e, tu d√©bloques la mission anniversaire.
    </p>

    <div class="grid">
      <div class="card">
        <h3>Contr√¥les</h3>
        <div class="small">
          ‚Üê / ‚Üí : tourner ¬∑ ‚Üë : boost ¬∑ Espace : drift/frein ¬∑ R : restart<br/>
          Manette : stick gauche (si dispo)
        </div>
      </div>
      <div class="card">
        <h3>Astuce ‚Äúcin√©‚Äù</h3>
        <div class="small">
          Tourne t√¥t, rel√¢che en sortie. Drift = style + contr√¥le, mais tu perds de la vitesse.
        </div>
      </div>
    </div>

    <div class="row">
      <button class="btn" id="startBtn">‚ñ∂ Lancer la descente</button>
      <button class="btn secondary" id="muteBtn">üîä Son: ON</button>
    </div>
    <div class="hint">Tip : clique une fois sur la page si ton navigateur bloque l‚Äôaudio.</div>
  </div>
</div>

<!-- FINISH OVERLAY -->
<div class="overlay" id="finishOverlay" style="display:none;">
  <div class="panel">
    <span class="kicker"><b>FINISH LINE</b> ¬∑ Mission d√©bloqu√©e</span>
    <h1>üèÅ Run valid√©. Maintenant : le vrai voyage.</h1>
    <p>
      <b>Naples + Procida + C√¥te Amalfitaine</b>. 4 jours : √©nergie, douceur, vue, et une surprise ‚Äúsignature‚Äù.
      Tu viens de gagner le droit de me laisser g√©rer toute la logistique. üòå
    </p>

    <div class="grid">
      <div class="card">
        <h3>Boarding pass</h3>
        <div class="small">
          Mode : ‚Äúz√©ro charge mentale‚Äù ¬∑ KPI : ton sourire (100%) ¬∑
          Bonus : meilleur coucher de soleil du syst√®me solaire.
        </div>
      </div>
      <div class="card">
        <h3>Objectif : 1er mars (Paris)</h3>
        <div class="countdown" id="countdown">
          <div class="timebox"><span class="num" id="days">00</span><span class="lab">Jours</span></div>
          <div class="timebox"><span class="num" id="hours">00</span><span class="lab">Heures</span></div>
          <div class="timebox"><span class="num" id="minutes">00</span><span class="lab">Minutes</span></div>
          <div class="timebox"><span class="num" id="seconds">00</span><span class="lab">Secondes</span></div>
        </div>
        <div class="row" style="margin-top:14px;">
          <button class="btn" id="acceptBtn">‚úÖ J‚Äôaccepte la mission</button>
          <button class="btn secondary" id="icsBtn">üìÖ Ajouter au calendrier</button>
          <button class="btn secondary" id="copyBtn">üì® Copier l‚Äôinvitation</button>
          <button class="btn secondary" id="replayBtn">üîÅ Replay</button>
        </div>
        <div class="hint" id="fineText">PS : oui, c‚Äôest un jeu vid√©o romantique. C‚Äôest assum√©.</div>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================
   0) Utils
========================= */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp  = (a,b,t)=>a+(b-a)*t;
const pad2  = (n)=>String(n).padStart(2,"0");
const prefersReduced = window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

/* =========================
   1) Canvas setup
========================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha:false });

const fx = document.getElementById("fx");
const fctx = fx.getContext("2d");

let DPR=1, W=0, H=0;
function resize(){
  DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  W = canvas.width = Math.floor(innerWidth * DPR);
  H = canvas.height = Math.floor(innerHeight * DPR);
  canvas.style.width = innerWidth + "px";
  canvas.style.height = innerHeight + "px";
  ctx.setTransform(DPR,0,0,DPR,0,0);

  fx.width = Math.floor(innerWidth * DPR);
  fx.height = Math.floor(innerHeight * DPR);
  fx.style.width = innerWidth + "px";
  fx.style.height = innerHeight + "px";
  fctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener("resize", resize);
resize();

/* =========================
   2) Simple WebAudio (whoosh + carve)
========================= */
let audioOn = true;
let audioCtx = null;
let master = null;
let noise = null;
let noiseGain = null;
let whooshOsc = null;
let whooshGain = null;

function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  master = audioCtx.createGain();
  master.gain.value = 0.55;
  master.connect(audioCtx.destination);

  // White noise buffer
  const bufferSize = 2 * audioCtx.sampleRate;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1) * 0.6;

  noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  noise.loop = true;

  noiseGain = audioCtx.createGain();
  noiseGain.gain.value = 0.0;

  const filter = audioCtx.createBiquadFilter();
  filter.type = "lowpass";
  filter.frequency.value = 900;

  noise.connect(filter);
  filter.connect(noiseGain);
  noiseGain.connect(master);

  // Whoosh tone
  whooshOsc = audioCtx.createOscillator();
  whooshOsc.type = "sawtooth";
  whooshOsc.frequency.value = 80;

  whooshGain = audioCtx.createGain();
  whooshGain.gain.value = 0.0;

  const whooshFilter = audioCtx.createBiquadFilter();
  whooshFilter.type = "bandpass";
  whooshFilter.frequency.value = 220;
  whooshFilter.Q.value = 0.8;

  whooshOsc.connect(whooshFilter);
  whooshFilter.connect(whooshGain);
  whooshGain.connect(master);

  noise.start();
  whooshOsc.start();
}

function setAudioIntensity(speed01, carve01){
  if(!audioOn || prefersReduced) return;
  if(!audioCtx) return;

  // noise = neige / vent
  const n = clamp(speed01, 0, 1);
  noiseGain.gain.setTargetAtTime(0.02 + n*0.18, audioCtx.currentTime, 0.04);

  // whoosh = vitesse + carving
  const w = clamp(speed01*0.9 + carve01*0.6, 0, 1);
  whooshGain.gain.setTargetAtTime(0.00 + w*0.10, audioCtx.currentTime, 0.04);
  whooshOsc.frequency.setTargetAtTime(60 + speed01*140, audioCtx.currentTime, 0.06);
}

/* =========================
   3) Input (keyboard + gamepad)
========================= */
const keys = new Set();
addEventListener("keydown", (e)=>{
  keys.add(e.code);
  if(["ArrowLeft","ArrowRight","ArrowUp","Space"].includes(e.code)) e.preventDefault();
});
addEventListener("keyup", (e)=>keys.delete(e.code));

function readGamepad(){
  const pads = navigator.getGamepads ? navigator.getGamepads() : [];
  for(const p of pads){
    if(!p) continue;
    const ax0 = p.axes && p.axes.length ? p.axes[0] : 0; // left stick X
    const ax1 = p.axes && p.axes.length>1 ? p.axes[1] : 0;

    // triggers vary; use buttons 7 (RT) and 6 (LT) if present
    const rt = p.buttons && p.buttons[7] ? p.buttons[7].value : 0;
    const lt = p.buttons && p.buttons[6] ? p.buttons[6].value : 0;

    return {
      steer: clamp(ax0, -1, 1),
      boost: clamp(rt, 0, 1),
      brake: clamp(lt, 0, 1) || (p.buttons && p.buttons[0] ? (p.buttons[0].pressed?1:0) : 0), // A as brake fallback
      drift: (p.buttons && p.buttons[1] ? (p.buttons[1].pressed?1:0) : 0), // B
      present: true
    };
  }
  return { steer:0, boost:0, brake:0, drift:0, present:false };
}

/* =========================
   4) Game state
========================= */
const hudSpeed = document.getElementById("speed");
const hudScore = document.getElementById("score");
const progEl = document.getElementById("prog");
const statePill = document.getElementById("statePill");

const startOverlay = document.getElementById("startOverlay");
const finishOverlay = document.getElementById("finishOverlay");

const TRACK_LEN = 5200;      // ‚Äúlongueur‚Äù de piste (units)
const TRACK_W   = 520;       // largeur (units)
const GATE_SPACING = 170;    // distance entre portes

let running = false;
let finished = false;

let player, camera, gates, particles;

function resetGame(){
  running = false;
  finished = false;

  player = {
    x: 0,
    y: 0,             // progression sur piste (0 -> TRACK_LEN)
    vx: 0,
    speed: 0,
    steer: 0,
    drift: 0,
    combo: 1,
    comboTimer: 0,
    score: 0,
    hp: 3,
    hitCooldown: 0
  };

  camera = {
    x: 0,
    y: 0,
    shake: 0,
    fov: 1.0
  };

  // G√©n√®re des portes altern√©es rouge/bleu
  gates = [];
  let side = -1;
  for(let gy=220; gy<TRACK_LEN; gy += GATE_SPACING){
    side *= -1;
    const offset = side * (TRACK_W*0.25 + Math.random()*TRACK_W*0.20);
    gates.push({
      y: gy,
      x: offset,
      w: 120,
      h: 46,
      passed: false,
      good: null
    });
  }

  particles = [];
  progEl.style.width = "0%";
  statePill.textContent = "READY";
  hudSpeed.textContent = "0 km/h";
  hudScore.textContent = "Score 0 ¬∑ Combo x1";
}

resetGame();

/* =========================
   5) Visual helpers
========================= */
function drawRoundedRect(c, x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  c.beginPath();
  c.moveTo(x+rr,y);
  c.arcTo(x+w,y,x+w,y+h,rr);
  c.arcTo(x+w,y+h,x,y+h,rr);
  c.arcTo(x,y+h,x,y,rr);
  c.arcTo(x,y,x+w,y,rr);
  c.closePath();
}

function worldToScreen(wx, wy){
  // Simple ‚Äúperspective‚Äù : plus loin = plus petit
  const relY = wy - camera.y;
  const depth = clamp(relY / 900, 0, 1.6);
  const scale = (1.25 - depth*0.55) * camera.fov; // proche plus grand
  const sx = innerWidth/2 + (wx - camera.x) * scale;
  const sy = innerHeight*0.62 - relY * (0.45 * scale);
  return { x:sx, y:sy, s:scale };
}

/* =========================
   6) FX confetti (finish / accept)
========================= */
let confetti = [];
function spawnConfetti(n=240){
  confetti = [];
  const cols = ["#ffffff","#ff9a9e","#fecfef","#75f3c6","#ff6bd6"];
  for(let i=0;i<n;i++){
    confetti.push({
      x: innerWidth/2 + (Math.random()*240 - 120),
      y: innerHeight/2 + (Math.random()*120 - 60),
      vx: (Math.random()*2 - 1) * (4 + Math.random()*10),
      vy: (Math.random()*-1) * (9 + Math.random()*12),
      g: 0.22 + Math.random()*0.18,
      s: 4 + Math.random()*7,
      r: Math.random()*Math.PI,
      vr: (Math.random()*2 - 1) * 0.25,
      c: cols[(Math.random()*cols.length)|0],
      life: 190 + (Math.random()*90|0)
    });
  }
}
function drawConfetti(){
  fctx.clearRect(0,0,innerWidth,innerHeight);
  for(const p of confetti){
    p.life--;
    p.vy += p.g;
    p.x += p.vx;
    p.y += p.vy;
    p.r += p.vr;
    fctx.save();
    fctx.translate(p.x, p.y);
    fctx.rotate(p.r);
    fctx.globalAlpha = Math.max(0, Math.min(1, p.life/240));
    fctx.fillStyle = p.c;
    fctx.fillRect(-p.s/2, -p.s/2, p.s, p.s*0.72);
    fctx.restore();
  }
  confetti = confetti.filter(p => p.life > 0 && p.y < innerHeight + 100);
  if(confetti.length) requestAnimationFrame(drawConfetti);
  else fctx.clearRect(0,0,innerWidth,innerHeight);
}

/* =========================
   7) Gameplay loop
========================= */
let lastT = performance.now();
function step(t){
  const dt = clamp((t - lastT) / 1000, 0, 0.033);
  lastT = t;

  // Background draw
  ctx.clearRect(0,0,innerWidth,innerHeight);

  // Star-ish mist layer
  if(!prefersReduced){
    const g = ctx.createRadialGradient(innerWidth/2, innerHeight*0.25, 0, innerWidth/2, innerHeight*0.25, innerWidth*0.9);
    g.addColorStop(0, "rgba(255,107,214,.10)");
    g.addColorStop(0.55,"rgba(0,0,0,0)");
    g.addColorStop(1,"rgba(0,0,0,.0)");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,innerWidth,innerHeight);
  }

  if(running && !finished){
    // Inputs
    const gp = readGamepad();
    const left  = keys.has("ArrowLeft") ? 1 : 0;
    const right = keys.has("ArrowRight") ? 1 : 0;
    const up    = keys.has("ArrowUp") ? 1 : 0;
    const brake = keys.has("Space") ? 1 : 0;

    const steer = gp.present ? gp.steer : (right - left);
    const boost = gp.present ? gp.boost : up;
    const drift = gp.present ? gp.drift : brake; // space = drift/frein

    // Physics-ish
    const baseAcc = 95;
    const boostAcc = 140 * boost;
    const drag = 0.030;
    const driftDrag = drift ? 0.060 : 0.0;

    // turn influence depends on speed
    const turnRate = 2.6;
    player.steer = lerp(player.steer, steer, 0.22);
    player.drift = lerp(player.drift, drift ? 1 : 0, 0.18);

    player.speed += (baseAcc + boostAcc) * dt;
    player.speed -= player.speed * (drag + driftDrag) * (60*dt);

    // clamp speed
    player.speed = clamp(player.speed, 120, 940);

    // ‚Äúcarving‚Äù: more steering = more lateral velocity
    const lateral = player.steer * (0.85 + (player.speed/940)*1.25) * (1.0 - player.drift*0.55);
    player.vx = lerp(player.vx, lateral * 240, 0.18);

    // advance along track
    player.y += player.speed * dt * 0.72;
    player.x += player.vx * dt;

    // borders collision
    const border = TRACK_W*0.48;
    if(player.x < -border || player.x > border){
      if(player.hitCooldown <= 0){
        player.hp -= 1;
        player.hitCooldown = 0.7;
        camera.shake = 1.0;
        player.combo = 1;
        player.comboTimer = 0;
      }
      player.x = clamp(player.x, -border, border);
      player.speed *= 0.86;
    }
    player.hitCooldown = Math.max(0, player.hitCooldown - dt);

    // combo decay
    if(player.comboTimer > 0) player.comboTimer -= dt;
    else player.combo = 1;

    // camera follow
    camera.y = lerp(camera.y, player.y - 220, 0.08);
    camera.x = lerp(camera.x, player.x * 0.45, 0.10);
    camera.fov = lerp(camera.fov, 1.0 + (player.speed/940)*0.12, 0.06);
    camera.shake = lerp(camera.shake, 0, 0.08);

    // Audio intensity
    if(audioOn && audioCtx){
      const speed01 = clamp((player.speed-120)/(940-120), 0, 1);
      const carve01 = clamp(Math.abs(player.steer) * (1.0 - player.drift*0.5), 0, 1);
      setAudioIntensity(speed01, carve01);
    }

    // progress bar
    const progress = clamp(player.y / TRACK_LEN, 0, 1);
    progEl.style.width = (progress*100).toFixed(1) + "%";

    // HUD speed/score
    const kmh = Math.round(player.speed * 0.12);
    hudSpeed.textContent = `${kmh} km/h`;
    hudScore.textContent = `Score ${Math.floor(player.score)} ¬∑ Combo x${player.combo}`;

    // Draw track (simple pseudo-3D)
    drawTrack(progress);

    // Gates
    handleAndDrawGates(dt);

    // Snow particles (screen space)
    if(!prefersReduced) spawnAndDrawSnow(dt, progress);

    // life indicator (pill)
    statePill.textContent = player.hp > 0 ? `HP ${player.hp}` : `CRASH`;
    statePill.style.borderColor = player.hp === 1 ? "rgba(255,71,100,.35)" : "rgba(255,255,255,.10)";
    statePill.style.background   = player.hp === 1 ? "rgba(255,71,100,.12)" : "rgba(255,255,255,.08)";

    // fail condition => restart overlay soft
    if(player.hp <= 0){
      running = false;
      startOverlay.style.display = "grid";
      document.getElementById("hudSub").textContent = "Oups. R pour recommencer (et mettre √ßa propre).";
      statePill.textContent = "RETRY";
    }

    // finish
    if(player.y >= TRACK_LEN){
      finished = true;
      running = false;
      onFinish();
    }
  } else {
    // Idle scene
    drawIdle();
  }

  requestAnimationFrame(step);
}

function drawTrack(progress){
  // Track trapezoid
  const topY = innerHeight*0.22;
  const botY = innerHeight*1.05;

  // perspective widths
  const topW = innerWidth*0.18;
  const botW = innerWidth*1.15;

  // lateral offset from camera.x
  const offset = -(camera.x / (TRACK_W*0.5)) * innerWidth*0.12;

  // snow gradient
  const g = ctx.createLinearGradient(0, topY, 0, botY);
  g.addColorStop(0, "rgba(235,240,255,.78)");
  g.addColorStop(1, "rgba(205,220,245,.96)");

  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(innerWidth/2 - topW + offset, topY);
  ctx.lineTo(innerWidth/2 + topW + offset, topY);
  ctx.lineTo(innerWidth/2 + botW + offset, botY);
  ctx.lineTo(innerWidth/2 - botW + offset, botY);
  ctx.closePath();
  ctx.fill();

  // subtle noise lines (fake texture)
  ctx.globalAlpha = 0.10;
  ctx.strokeStyle = "#ffffff";
  for(let i=0;i<18;i++){
    const y = topY + (i/18)*(botY-topY);
    ctx.beginPath();
    ctx.moveTo(innerWidth/2 - (topW + (botW-topW)*(i/18)) + offset, y);
    ctx.lineTo(innerWidth/2 + (topW + (botW-topW)*(i/18)) + offset, y);
    ctx.stroke();
  }
  ctx.globalAlpha = 1;

  // sides glow
  ctx.globalAlpha = 0.10 + (progress*0.18);
  ctx.strokeStyle = "rgba(255,107,214,.7)";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(innerWidth/2 - topW + offset, topY);
  ctx.lineTo(innerWidth/2 - botW + offset, botY);
  ctx.moveTo(innerWidth/2 + topW + offset, topY);
  ctx.lineTo(innerWidth/2 + botW + offset, botY);
  ctx.stroke();
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;

  // motion blur vignette
  if(!prefersReduced){
    const v = ctx.createRadialGradient(innerWidth/2, innerHeight*0.65, innerWidth*0.10, innerWidth/2, innerHeight*0.65, innerWidth*0.75);
    v.addColorStop(0, "rgba(0,0,0,0)");
    v.addColorStop(1, "rgba(0,0,0,.30)");
    ctx.fillStyle = v;
    ctx.fillRect(0,0,innerWidth,innerHeight);
  }

  // camera shake overlay
  if(camera.shake > 0.02){
    ctx.globalAlpha = camera.shake * 0.15;
    ctx.fillStyle = "rgba(255,255,255,1)";
    ctx.fillRect(0,0,innerWidth,innerHeight);
    ctx.globalAlpha = 1;
  }
}

function handleAndDrawGates(dt){
  // draw from far to near
  for(let i=gates.length-1;i>=0;i--){
    const g = gates[i];
    const wy = g.y;
    if(wy < camera.y - 80) continue;
    if(wy > camera.y + 980) continue;

    const ws = worldToScreen(g.x, wy);
    const w = g.w * ws.s;
    const h = g.h * ws.s;

    // poles positions on track screen
    const isRed = (i % 2 === 0);
    const col = isRed ? "rgba(255,71,100,1)" : "rgba(71,158,255,1)";
    const glow = isRed ? "rgba(255,71,100,.35)" : "rgba(71,158,255,.35)";

    // gate body
    ctx.save();
    ctx.translate(ws.x, ws.y);
    ctx.rotate((-player.steer) * 0.08);
    ctx.globalAlpha = clamp(ws.s*1.2, 0.15, 1);

    // shadow
    ctx.fillStyle = "rgba(0,0,0,.25)";
    drawRoundedRect(ctx, -w/2+6, -h/2+8, w, h, 10*ws.s);
    ctx.fill();

    // main
    ctx.fillStyle = col;
    ctx.shadowColor = glow;
    ctx.shadowBlur = 24*ws.s;
    drawRoundedRect(ctx, -w/2, -h/2, w, h, 12*ws.s);
    ctx.fill();
    ctx.shadowBlur = 0;

    ctx.fillStyle = "rgba(255,255,255,.9)";
    ctx.font = `${Math.max(10, 12*ws.s)}px -apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(isRed ? "FOCUS" : "FLOW", 0, 0);

    // poles
    ctx.globalAlpha *= 0.75;
    ctx.fillStyle = "rgba(255,255,255,.95)";
    ctx.fillRect(-w/2 + 8*ws.s, -h/2 - 26*ws.s, 5*ws.s, 62*ws.s);
    ctx.fillRect( w/2 - 13*ws.s, -h/2 - 26*ws.s, 5*ws.s, 62*ws.s);

    ctx.restore();

    // collision / pass check
    if(!g.passed && Math.abs((g.y - player.y)) < 55){
      const dx = Math.abs(player.x - g.x);
      if(dx < 120){
        // good pass
        g.passed = true;
        g.good = true;

        player.combo = clamp(player.combo + 1, 1, 9);
        player.comboTimer = 1.2;

        const styleBonus = 1 + player.combo*0.15;
        const speedBonus = clamp((player.speed-120)/(940-120), 0, 1) * 60;
        player.score += (220 + speedBonus) * styleBonus;

        camera.shake = Math.max(camera.shake, 0.18);

        // burst particles
        burst(ws.x, ws.y, isRed ? "#ff4764" : "#479eff");
      } else {
        // missed gate (penalty)
        g.passed = true;
        g.good = false;
        player.combo = 1;
        player.comboTimer = 0;

        player.score = Math.max(0, player.score - 120);
        camera.shake = Math.max(camera.shake, 0.35);
        player.speed *= 0.92;

        burst(ws.x, ws.y, "#ffffff");
      }
    }
  }
}

function burst(x,y,color){
  if(prefersReduced) return;
  for(let i=0;i<22;i++){
    particles.push({
      x, y,
      vx: (Math.random()*2-1) * (2 + Math.random()*6),
      vy: (Math.random()*2-1) * (2 + Math.random()*6),
      life: 0.55 + Math.random()*0.35,
      c: color,
      s: 2 + Math.random()*3
    });
  }
}

function spawnAndDrawSnow(dt, progress){
  // screen snow streaks based on speed
  const speed01 = clamp((player.speed-120)/(940-120),0,1);
  const rate = 20 + speed01*80;

  // spawn
  const toSpawn = Math.floor(rate * dt);
  for(let i=0;i<toSpawn;i++){
    particles.push({
      x: Math.random()*innerWidth,
      y: Math.random()*innerHeight*0.7,
      vx: (-player.steer*40) + (Math.random()*2-1)*10,
      vy: 180 + speed01*520 + Math.random()*120,
      life: 0.25 + Math.random()*0.35,
      c: "rgba(255,255,255,.9)",
      s: 1 + Math.random()*2.4,
      snow:true
    });
  }

  // draw
  ctx.save();
  ctx.globalCompositeOperation = "screen";
  for(const p of particles){
    p.life -= dt;
    p.x += p.vx * dt;
    p.y += p.vy * dt;

    const a = clamp(p.life/0.6, 0, 1);
    ctx.globalAlpha = p.snow ? a*0.65 : a;

    ctx.fillStyle = p.c;
    if(p.snow){
      // streak
      ctx.fillRect(p.x, p.y, p.s*0.9, p.s*10);
    } else {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.s, 0, Math.PI*2);
      ctx.fill();
    }
  }
  ctx.restore();
  ctx.globalAlpha = 1;

  // cleanup
  particles = particles.filter(p => p.life > 0 && p.y < innerHeight + 60 && p.x > -60 && p.x < innerWidth + 60);
}

function drawIdle(){
  // Pretty idle: track + title ghost
  camera.x = lerp(camera.x, 0, 0.06);
  camera.y = lerp(camera.y, 0, 0.06);
  drawTrack(0);

  ctx.globalAlpha = 0.22;
  ctx.fillStyle = "rgba(255,255,255,1)";
  ctx.font = `900 ${Math.max(18, innerWidth*0.022)}px -apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial`;
  ctx.textAlign = "center";
  ctx.fillText("MISSION : H√âL√àNE ‚Äî SKI RUN", innerWidth/2, innerHeight*0.78);
  ctx.globalAlpha = 1;
}

/* =========================
   8) Start / Finish
========================= */
document.getElementById("startBtn").addEventListener("click", () => {
  initAudio();
  if(audioCtx && audioCtx.state === "suspended") audioCtx.resume();
  startOverlay.style.display = "none";
  running = true;
  finished = false;
  statePill.textContent = "GO";
  document.getElementById("hudSub").textContent = "‚Üê ‚Üí carve ¬∑ ‚Üë boost ¬∑ Espace drift";
});

document.getElementById("muteBtn").addEventListener("click", async (e) => {
  initAudio();
  if(audioCtx && audioCtx.state === "suspended") await audioCtx.resume();
  audioOn = !audioOn;
  e.target.textContent = audioOn ? "üîä Son: ON" : "üîá Son: OFF";
  if(noiseGain) noiseGain.gain.value = 0;
  if(whooshGain) whooshGain.gain.value = 0;
});

addEventListener("keydown", (e)=>{
  if(e.code === "Enter" && startOverlay.style.display !== "none"){
    document.getElementById("startBtn").click();
  }
  if(e.code === "KeyR"){
    resetGame();
    startOverlay.style.display = "grid";
    finishOverlay.style.display = "none";
    confetti = [];
    fctx.clearRect(0,0,innerWidth,innerHeight);
  }
});

function onFinish(){
  statePill.textContent = "FINISH";
  document.getElementById("hudSub").textContent = "Run clean. Mission unlocked.";
  finishOverlay.style.display = "grid";
  spawnConfetti();
  drawConfetti();
}

/* =========================
   9) Accept / Replay + ICS + Copy
========================= */
document.getElementById("replayBtn").addEventListener("click", ()=>{
  resetGame();
  finishOverlay.style.display = "none";
  startOverlay.style.display = "grid";
});

document.getElementById("acceptBtn").addEventListener("click", () => {
  spawnConfetti(320);
  drawConfetti();
  pulseText("Mission accept√©e. Prochaine √©tape : la surprise. ‚ú®");
});

function pulseText(text){
  const el = document.getElementById("fineText");
  const old = el.textContent;
  el.textContent = text;
  el.animate([{opacity:.35},{opacity:1}],{duration:450,easing:"ease-out"});
  setTimeout(()=>{ el.textContent = old; }, 2400);
}

/* Countdown Europe/Paris */
function getZonedTimestamp({ year, monthIndex, day, hour=0, minute=0, second=0, timeZone }) {
  const utcGuess = Date.UTC(year, monthIndex, day, hour, minute, second);
  const dtf = new Intl.DateTimeFormat("en-US", {
    timeZone, hour12:false,
    year:"numeric", month:"2-digit", day:"2-digit",
    hour:"2-digit", minute:"2-digit", second:"2-digit"
  });
  function partsInZone(ms){
    const parts = dtf.formatToParts(new Date(ms));
    const get = (t)=> +parts.find(p=>p.type===t).value;
    return { y:get("year"), m:get("month"), d:get("day"), hh:get("hour"), mm:get("minute"), ss:get("second") };
  }
  let corrected = utcGuess;
  for(let i=0;i<2;i++){
    const p = partsInZone(corrected);
    const asIfUTC = Date.UTC(p.y, p.m-1, p.d, p.hh, p.mm, p.ss);
    const desired = Date.UTC(year, monthIndex, day, hour, minute, second);
    corrected -= (asIfUTC - desired);
  }
  return corrected;
}
const targetDate = getZonedTimestamp({ year:2026, monthIndex:2, day:1, hour:0, minute:0, second:0, timeZone:"Europe/Paris" });

setInterval(()=>{
  const now = Date.now();
  const d = targetDate - now;
  if(d <= 0){
    document.getElementById("countdown").innerHTML = `<div class="timebox" style="min-width:220px;"><span class="num">üéÇ</span><span class="lab">C‚Äôest le jour J</span></div>`;
    return;
  }
  const days = Math.floor(d/(1000*60*60*24));
  const hours = Math.floor((d%(1000*60*60*24))/(1000*60*60));
  const minutes = Math.floor((d%(1000*60*60))/(1000*60));
  const seconds = Math.floor((d%(1000*60))/1000);
  document.getElementById("days").textContent = pad2(days);
  document.getElementById("hours").textContent = pad2(hours);
  document.getElementById("minutes").textContent = pad2(minutes);
  document.getElementById("seconds").textContent = pad2(seconds);
}, 1000);

/* ICS */
function toICSDateUTC(ms){
  const d = new Date(ms);
  const p = (n)=>String(n).padStart(2,"0");
  return d.getUTCFullYear()+p(d.getUTCMonth()+1)+p(d.getUTCDate())+"T"+p(d.getUTCHours())+p(d.getUTCMinutes())+p(d.getUTCSeconds())+"Z";
}
document.getElementById("icsBtn").addEventListener("click", () => {
  const dtStart = targetDate;
  const dtEnd = targetDate + 60*60*1000;
  const uid = (crypto.randomUUID ? crypto.randomUUID() : (Date.now()+"@mission"));
  const ics =
`BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
PRODID:-//Mission Helene//FR
BEGIN:VEVENT
UID:${uid}
DTSTAMP:${toICSDateUTC(Date.now())}
DTSTART:${toICSDateUTC(dtStart)}
DTEND:${toICSDateUTC(dtEnd)}
SUMMARY:üéâ Objectif 1er Mars
DESCRIPTION:D√©ploiement surprise (Europe/Paris).
END:VEVENT
END:VCALENDAR`;
  const blob = new Blob([ics], { type:"text/calendar;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "objectif-1er-mars.ics";
  a.click();
  URL.revokeObjectURL(url);
});

/* Copy invite */
document.getElementById("copyBtn").addEventListener("click", async () => {
  const msg =
`H√©l√®ne ‚ù§Ô∏è

Je t‚Äôai cod√© une descente de ski (oui) et √† la fin : mission d√©bloqu√©e.

Naples + Procida + C√¥te Amalfitaine.
4 jours : √©nergie, douceur, vue, et une surprise ‚Äúsignature‚Äù.

Tu acceptes la mission ? ‚ú®`;
  try{
    await navigator.clipboard.writeText(msg);
    pulseText("Invitation copi√©e ‚úÖ");
  }catch(e){
    pulseText("Copie bloqu√©e ‚Äî copie manuelle affich√©e.");
    alert(msg);
  }
});

/* =========================
   10) Boot
========================= */
requestAnimationFrame(step);
</script>
</body>
</html>
